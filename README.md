# Тестовое задание для Middle-разработчика (Чат и уведомления в мультиплеерной сессии)

## Общая информация

Добрый день! Это тестовое задание для позиции Middle-разработчика в нашем MOBA-проекте, который использует Photon dedicated server для мультиплеерной логики. Задание фокусируется на проверке ваших навыков в области:

- **Архитектуры**: SOLID, модульность, dependency injection.
- **Паттернов проектирования**: Mediator, Builder и другие.
- **Реактивного программирования**: System.Reactive или UniRx.
- **Асинхронного программирования**: async/await, Tasks.
- **Мультиплеерной логики**: синхронизация состояний, обработка событий через mocks (без реального Photon SDK).

**Цель задания**: Реализовать систему чата и уведомлений в мультиплеерной сессии (лобби или игра в MOBA-стиле) с использованием mocked сетевой логики. Это позволит нам оценить, как вы структурируете код, делаете его тестируемым и готовым к интеграции с реальными сетевыми сервисами, такими как Photon.

**Ожидаемое время выполнения**: 4–5 часов. Если потребуется больше времени, укажите в README вашего решения, почему.

**Дедлайн**: 3–5 дней с момента получения задания. Для уточнений пишите на development.savannah@gmail.com.

**Конфиденциальность**: Не публикуйте решение публично. Используйте этот GitHub-репозиторий (если реализуете с Unity, то предпочтительна ссылка на свой репозиторий) или zip-архив (укажите причину этого выбора в своем README).

**Работа с Git**: Мы используем **GitFlow** для управления ветками. Создавайте feature-ветки (e.g., `feature/chat-system`) для ваших изменений. Мёржить ветки в `development` **не нужно** — это симуляция для проверки ваших навыков работы с Git. Достаточно push изменений в вашу feature-ветку и указать её в README.

## Описание задания

Вам нужно расширить предоставленный шаблон проекта для создания системы чата и уведомлений в мультиплеерной сессии. Система должна имитировать поведение в MOBA-лобби или игре: игроки могут отправлять сообщения в чат, получать уведомления (например, о старте матча или убийствах), с учётом сетевых задержек и сценариев disconnect/reconnect.

### Ключевые требования

- **Архитектура**:
  - Используйте layered architecture (например, UI layer, Network layer, Data layer).
  - Примените dependency injection (рекомендуется Microsoft.Extensions.DependencyInjection или Zenject для Unity).
- **Паттерны**:
  - **Builder** для формирования уведомлений (уже частично реализован в `NotificationBuilder.cs`).
  - **Mediator** для маршрутизации сообщений и событий (добавьте его для обработки разных типов сообщений/уведомлений).
- **Реактивное программирование**:
  - Используйте **System.Reactive** (в шаблоне) или **UniRx** (если интегрируете с Unity) для обработки потоков событий (например, `Subject`/`Observable` для broadcast сообщений и уведомлений).
- **Асинхронность**:
  - Обработайте задержки и retry с использованием async/await (например, имитация latency в mocks, retry при disconnect).
- **Мультиплеерная логика (mocked)**:
  - Не используйте реальный Photon SDK. Расширьте интерфейс `IChatNetwork` и mocks для симуляции:
    - **Broadcast сообщений/уведомлений**: для нескольких "виртуальных" клиентов (добавьте список клиентов в `MockChatNetwork` для имитации комнаты).
    - **Authority**: "серверный" mock решает конфликты (например, фильтрует дубликаты сообщений).
    - **Latency**: используйте `Task.Delay(100-500ms)` для имитации сетевых задержек.
    - **Disconnect/reconnect**: уже частично реализовано; расширьте для сценариев потери соединения.
- **Дополнительные фичи**:
  - **Фильтрация сообщений**: реализуйте публичный и командный чат (используйте enum для типов чата).
  - **Несколько клиентов**: в mocks симулируйте 2–3 "игрока" (локальные instances), где отправка от одного видна всем.
  - **UI (опционально)**: если хотите интегрировать с Unity, добавьте простой UI (TextMeshPro для чата, кнопки для отправки). Задание можно выполнить без Unity — фокус на логике.
- **Тестирование**:
  - Напишите дополнительные unit-тесты с **NUnit** и **Moq** (например, для фильтрации, retry, broadcast).
  - Покройте не менее 80% кода тестами (используйте coverage tools, например, `dotnet test --collect:"XPlat Code Coverage"`).

### Что проверяем

- Чистота и модульность кода (принципы SOLID).
- Правильное применение паттернов и реактивного программирования для real-time обновлений.
- Грамотная обработка асинхронных сценариев и ошибок.
- Понимание мультиплеерных концепций (синхронизация, authority) через mocks.
- Качество unit-тестов и документации.
- Умение работать с Git по GitFlow (правильное именование веток, чистая история коммитов).

## Структура шаблона проекта

Проект — это .NET Solution (.NET 9.0), совместимая с Visual Studio или VS Code. Структура:

- **ChatSystem.Core**: Основная логика.
  - `IChatNetwork.cs`: Интерфейс для mocked сети (имитирует Photon-like поведение: `SendMessage`, `RaiseEvent`, `ISubject` для событий).
  - `ChatManager.cs`: Менеджер чата с подпиской на события и асинхронной отправкой.
  - `NotificationBuilder.cs`: Builder-паттерн для уведомлений.
- **ChatSystem.Mocks**: Моки для тестов и runtime-симуляции.
  - `MockChatNetwork.cs`: Custom mock с latency и disconnect.
- **ChatSystem.Tests**: Unit-тесты с NUnit и Moq.
  - `ChatManagerTests.cs`: Примеры тестов (отправка сообщений, уведомлений, retry).

### Зависимости

- `System.Reactive` (для реактивного программирования).
- `Moq` (для mocks в тестах).
- `NUnit` (для unit-тестов).

## Инструкции по установке и запуску

1. **Требования**:
   - .NET SDK 9.0 ([скачать](https://dotnet.microsoft.com/download)).
   - Visual Studio 2022+ или VS Code с C# extension.
   - Опционально: Unity 2022+ для UI-интеграции (если решите добавить).

2. **Клонирование и настройка**:
   - Клонируйте repo: `git clone https://github.com/YamakasiTeam/CoreApplicantsRepo.git`.
   - Откройте в VS: `ChatSystem.sln`.
   - Восстановите пакеты: `dotnet restore`.
   - Если добавляете Unity: создайте Unity-проект, импортируйте .NET проекты как assemblies, настройте DI.

3. **Работа с Git**:
   - Используйте **GitFlow**: создайте feature-ветку (e.g., `feature/chat-system`) от `main`.
   - Делайте коммиты с понятными сообщениями (e.g., `Add team chat filtering`, `Add Mediator pattern`).
   - Мёрж в `development` **не нужен** — это симуляция. Просто push в вашу feature-ветку.

4. **Запуск тестов**:
   - В Visual Studio: Test Explorer → Run All.
   - В командной строке: `dotnet test ChatSystem.Tests/ChatSystem.Tests.csproj`.
   - Все тесты (3 примера в шаблоне) должны проходить.

5. **Расширение проекта**:
   - Добавьте код в `Core`/`Mocks` для новых фич.
   - Для Unity: создайте скрипты (e.g., `ChatUI.cs`), инжектьте `ChatManager` через DI.
   - Импортируйте пакеты в коде (не pip, так как .NET).

6. **Отладка**:
   - В mocks добавьте логи (`Console.WriteLine`) для симуляции событий.
   - Тестируйте локально: создайте console app в solution для demo (e.g., отправьте сообщения и проверьте broadcast).

## Как сабмитить решение

- **Формат**:
  - **GitHub repo** (fork нашего шаблона или новый приватный):
    - Создайте feature-ветку по GitFlow (e.g., `feature/chat-system`).
    - Push изменений с чистой историей коммитов (избегайте `WIP` или неинформативных сообщений).
    - В README опишите:
      - Архитектуру (диаграммы в Draw.io приветствуются).
      - Как mocks имитируют Photon (e.g., broadcast, latency).
      - Потраченное время и трудности (если были).
      - Инструкции по запуску (включая Unity, если добавлено).
    - Укажите результаты тестов (скриншот или log, e.g., `dotnet test --logger "console;verbosity=detailed"`).
  - **Альтернатива**: Zip-архив с проектом + PDF с объяснениями.
- **Не добавляйте**: Реальный Photon SDK или внешние зависимости без согласования.

## Пример расширения

- **В `ChatManager`**:
  - Добавьте метод `SendTeamMessage(ChatType type, string message, string sender)` с фильтрацией по `ChatType.Public`/`ChatType.Team`.
- **В `MockChatNetwork`**:
  - Добавьте `List<string> clients` для broadcast только подключенным клиентам.
  - Реализуйте фильтрацию по типу чата.
- **Тест**:
  ```csharp
  [Test]
  public async Task Broadcast_ToMultipleClients()
  {
      // Arrange: два клиента, отправка сообщения, проверка получения обоими
  }
  ```

## Советы

- Убедитесь, что все mocks настроены до создания `ChatManager` в тестах (иначе подписки могут не сработать).
- Если используете Unity, добавьте UI-компоненты (TextMeshPro) и опишите, как они интегрируются с `ChatManager`.
- Для тестов используйте `Moq` для проверки вызовов (e.g., `mockNetwork.Verify(...)`).
- Документируйте архитектуру в README: как Mediator распределяет события, как mocks имитируют Photon.

Удачи! Мы ждём вашего решения и готовы обсудить на интервью. Если есть вопросы, пишите на development.savannah@gmail.com.
